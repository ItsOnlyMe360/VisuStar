<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisuStar</title>
    <style>
        /* Basic Reset & Global Styles */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Controls Panel */
        #controls-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 320px;
            height: 100%;
            background-color: rgba(22, 33, 55, 0.9);
            backdrop-filter: blur(8px);
            color: #fff;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            z-index: 50;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            transform: translateX(0);
        }

        #controls-panel.hidden {
            transform: translateX(-100%);
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .controls-header h2 {
            font-size: 1.5rem;
            font-weight: bold;
            color: #bfdbfe; /* blue-200 */
            margin: 0;
        }

        #toggle-visibility-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: #9ca3af; /* gray-400 */
            border-radius: 9999px;
            transition: color 0.2s, background-color 0.2s;
        }

        #toggle-visibility-btn:hover {
            color: #fff;
            background-color: #334155; /* slate-700 */
        }
        
        #toggle-visibility-btn svg, #show-controls-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            stroke-width: 1.5;
        }
        
        /* Show Controls Button */
         #show-controls-btn {
            position: fixed;
            top: 16px;
            right: 16px;
            background-color: rgba(51, 65, 85, 0.8);
            color: white;
            padding: 12px;
            border-radius: 9999px;
            border: none;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -4px rgba(0,0,0,.1);
            z-index: 40;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            opacity: 1;
            visibility: visible;
        }

        #show-controls-btn.hidden {
           opacity: 0;
           visibility: hidden;
        }
        
        #show-controls-btn:hover {
            background-color: rgba(71, 85, 105, 0.9);
        }
        
        #show-controls-btn:focus {
             outline: 2px solid #60a5fa;
        }
        
        /* Control Groups */
        .control-group {
            margin-bottom: 24px;
        }
        
        .control-group h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #93c5fd; /* blue-300 */
            border-bottom: 1px solid #475569; /* gray-600 */
            padding-bottom: 8px;
            margin-bottom: 12px;
            margin-top: 0;
        }

        /* Input Styles */
        .input-container {
            margin-bottom: 16px;
        }
        
        .input-container label, .toggle-container label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #d1d5db; /* gray-300 */
            margin-bottom: 4px;
        }
        
        .input-container label span {
            font-weight: 600;
            color: #93c5fd; /* blue-300 */
        }
        
        .input-container input[type="range"] {
            width: 100%;
            height: 8px;
            background: #4b5563; /* gray-600 */
            border-radius: 9999px;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        .input-container input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 16px;
          height: 16px;
          background: #3b82f6; /* blue-500 */
          border-radius: 50%;
          transition: background-color 0.2s;
        }
        .input-container input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            border: none;
        }

        .color-input-container {
            margin-bottom: 12px;
        }
        
        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-input-wrapper input[type="color"] {
            width: 40px;
            height: 40px;
            padding: 2px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #374151; /* gray-700 */
        }
        
        .color-input-wrapper input[type="text"] {
            width: 100%;
            padding: 4px 8px;
            background-color: #374151; /* gray-700 */
            border: 1px solid #4b5563; /* gray-600 */
            border-radius: 6px;
            font-size: 0.875rem;
            color: #d1d5db; /* gray-200 */
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .toggle-container label { margin-bottom: 0; }
        .toggle-container button {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            transition: background-color 0.2s;
            border: none;
            cursor: pointer;
        }
        .toggle-container button.enabled {
            background-color: #3b82f6; /* blue-500 */
            color: #fff;
        }
        .toggle-container button.disabled {
            background-color: #4b5563; /* gray-600 */
            color: #d1d5db; /* gray-300 */
        }
        
        #audio-toggle.enabled {
            background-color: #22c55e; /* green-500 */
        }

        #recreate-btn {
            width: 100%;
            background-color: #6366f1; /* indigo-500 */
            color: white;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 6px;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
            border: none;
            cursor: pointer;
        }

        #recreate-btn:hover {
            background-color: #4f46e5; /* indigo-600 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        #info-text {
            font-size: 0.75rem;
            color: #9ca3af; /* gray-400 */
            margin-top: 24px;
            text-align: center;
        }
        
        /* Custom Scrollbar */
        #controls-panel::-webkit-scrollbar {
            width: 8px;
        }
        #controls-panel::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        #controls-panel::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        #controls-panel::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }

    </style>
</head>
<body>
    
    <canvas id="bg-canvas"></canvas>

    <div id="controls-panel">
        <div class="controls-header">
            <h2>Controls</h2>
            <button id="toggle-visibility-btn" title="Hide Controls (Press H)">
                <svg fill="none" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                </svg>
            </button>
        </div>

        <!-- Populated by JavaScript -->
        <div id="controls-content"></div>

        <p id="info-text">Press 'H' to toggle this panel. Press 'L' to toggle the settings button.</p>
    </div>
    
    <button id="show-controls-btn" class="hidden" title="Show Controls (Press H)">
      <svg fill="none" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.646.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 0 1 0 1.905c-.007.379.137.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 0 1-.22.128c-.333.184-.582.496-.646.87l-.212 1.282c-.09.542-.56.94-1.11.94h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.645-.87a6.52 6.52 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.759 6.759 0 0 1 0-1.905c.007-.379-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.184.582-.496.645-.87l.212-1.282Z" />
        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
      </svg>
    </button>
    
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.142.0"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- CONSTANTS ---
        const PARTICLE_RANGE = 1500;
        const MAX_NEBULA_OCTAVES = 10;
        const MAX_AUDIO_VISUAL_EFFECT_STRENGTH = 2.5;

        const INITIAL_PARAMS = {
          particleCount: 75000,
          speed: 0.05,
          directionY: 0.1,
          directionX: 0.0,
          particleSize: 2.5,
          resolution: 1.5,
          opacityFalloff: 1.5,
          mouseInteraction: true,
          particleColor1: '#66ccff',
          particleColor2: '#cc99ff',
          particleHighlightColor: '#ffee99',
          nebulaColor1: '#001133',
          nebulaColor2: '#0d0025',
          nebulaAccent1: '#223366',
          nebulaAccent2: '#302255',
          nebulaOctaves: 6,
          nebulaScale: 1.0,
          nebulaSpeed: 0.015,
          nebulaBrightness: 1.0,
          nebulaColorMixFactor1: 4.0,
          nebulaDynamicShiftIntensity: 0.03,
          audioReactivityEnabled: false,
          audioSensitivity: 0.5,
        };

        const BACKGROUND_VERTEX_SHADER = `
          varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`;
        
        const BACKGROUND_FRAGMENT_SHADER = `
          precision highp float;
          uniform vec2 u_resolution; uniform float u_time; varying vec2 vUv;
          uniform vec3 u_nebulaBaseCol1; uniform vec3 u_nebulaBaseCol2; uniform vec3 u_nebulaAccentCol1; uniform vec3 u_nebulaAccentCol2;
          uniform int u_nebulaOctaves; uniform float u_nebulaScale; uniform float u_nebulaSpeed; uniform float u_nebulaBrightness;
          uniform float u_nebulaColorMixFactor1; uniform float u_nebulaDynamicShiftIntensity;

          float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); }
          float noise(vec2 st) {
              vec2 i = floor(st); vec2 f = fract(st);
              float a = random(i); float b = random(i + vec2(1.0, 0.0));
              float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
              vec2 u = f * f * (3.0 - 2.0 * f);
              return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
          }
          float fbm(vec2 st) {
              float value = 0.0; float amplitude = 0.5;
              for (int i = 0; i < ${MAX_NEBULA_OCTAVES}; i++) {
                  if (i >= u_nebulaOctaves) break;
                  value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5;
              }
              return value;
          }

          void main() {
              vec2 st = vUv * u_nebulaScale; st.x *= u_resolution.x / u_resolution.y;
              vec2 q = vec2(fbm(st + u_time * u_nebulaSpeed), fbm(st + vec2(1.0) + u_time * u_nebulaSpeed * 0.75));
              vec2 r = vec2(fbm(st + q + u_time * u_nebulaSpeed * 0.5), fbm(st + q + vec2(1.0) + u_time * u_nebulaSpeed * 0.25));
              float f = fbm(st + r);
              float timePhase = u_time * 0.03;
              vec3 shiftVec1 = vec3(sin(timePhase), cos(timePhase * 0.7), sin(timePhase * 1.2)) * u_nebulaDynamicShiftIntensity;
              vec3 shiftVec2 = vec3(cos(timePhase * 0.8), sin(timePhase * 0.5), cos(timePhase)) * u_nebulaDynamicShiftIntensity;
              vec3 finalBaseCol1 = u_nebulaBaseCol1 + shiftVec1; vec3 finalBaseCol2 = u_nebulaBaseCol2 + shiftVec2;
              vec3 finalAccentCol1 = u_nebulaAccentCol1 + shiftVec1; vec3 finalAccentCol2 = u_nebulaAccentCol2 + shiftVec2;
              vec3 color = mix(finalBaseCol1, finalBaseCol2, clamp((f * f) * u_nebulaColorMixFactor1, 0.0, 1.0));
              color = mix(color, finalAccentCol1, clamp(length(q), 0.0, 1.0));
              color = mix(color, finalAccentCol2, clamp(length(r.x), 0.0, 1.0));
              color *= (f * f * f + 0.6 * f * f + 0.5 * f) * u_nebulaBrightness;
              gl_FragColor = vec4(color, 1.0);
          }`;
        
        const PARTICLE_VERTEX_SHADER = `
          uniform float uParticleSizeBase; uniform float uAudioInfluence;
          attribute float depth; attribute vec3 colorAttrib; attribute float twinkleOffsetAttrib;
          varying float vDepth; varying vec3 vColor; varying float vTwinkleOffset;
          void main() {
            vDepth = depth; vColor = colorAttrib; vTwinkleOffset = twinkleOffsetAttrib;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float audioReactiveSizeFactor = 1.0 + uAudioInfluence * ${MAX_AUDIO_VISUAL_EFFECT_STRENGTH.toFixed(1)};
            gl_PointSize = uParticleSizeBase * audioReactiveSizeFactor * (300.0 / max(0.001, -mvPosition.z));
            gl_Position = projectionMatrix * mvPosition;
          }`;
          
        const PARTICLE_FRAGMENT_SHADER = `
          uniform sampler2D pointTexture; uniform float opacityFalloff; uniform float u_time;
          varying float vDepth; varying vec3 vColor; varying float vTwinkleOffset;
          void main() {
            vec4 texColor = texture2D(pointTexture, gl_PointCoord);
            if (texColor.a < 0.1) discard;
            float clampedDepth = clamp(vDepth, 0.0, 1.0);
            float finalOpacity = pow(clampedDepth, opacityFalloff);
            float twinkleFactor = (sin(u_time * 2.5 + vTwinkleOffset) + 1.0) * 0.5;
            twinkleFactor = 0.5 + twinkleFactor * 0.5;
            gl_FragColor = vec4(vColor, texColor.a * finalOpacity * twinkleFactor);
          }`;


        // --- MAIN APPLICATION CLASS ---
        class VisuStarApp {
            constructor() {
                this.params = { ...INITIAL_PARAMS };
                this.canvas = document.getElementById('bg-canvas');
                this.clock = new THREE.Clock();
                this.mouseX = 0;
                this.mouseY = 0;
                this.init();
            }

            init() {
                this.setupScene();
                this.setupControls();
                this.setupEventListeners();
                this.createOrUpdateParticles();
                this.animate();
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 100, 3000);
                this.camera.position.z = 500;
                
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setPixelRatio(this.params.resolution);
                this.renderer.setSize(window.innerWidth, window.innerHeight);

                this.setupBackground();
                this.particleTexture = this.createParticleTexture();
            }
            
            setupBackground() {
                const backgroundGeometry = new THREE.PlaneGeometry(2, 2);
                this.backgroundMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        u_time: { value: 0.0 },
                        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        u_nebulaBaseCol1: { value: new THREE.Color(this.params.nebulaColor1) },
                        u_nebulaBaseCol2: { value: new THREE.Color(this.params.nebulaColor2) },
                        u_nebulaAccentCol1: { value: new THREE.Color(this.params.nebulaAccent1) },
                        u_nebulaAccentCol2: { value: new THREE.Color(this.params.nebulaAccent2) },
                        u_nebulaOctaves: { value: this.params.nebulaOctaves },
                        u_nebulaScale: { value: this.params.nebulaScale },
                        u_nebulaSpeed: { value: this.params.nebulaSpeed },
                        u_nebulaBrightness: { value: this.params.nebulaBrightness },
                        u_nebulaColorMixFactor1: { value: this.params.nebulaColorMixFactor1 },
                        u_nebulaDynamicShiftIntensity: { value: this.params.nebulaDynamicShiftIntensity },
                    },
                    vertexShader: BACKGROUND_VERTEX_SHADER,
                    fragmentShader: BACKGROUND_FRAGMENT_SHADER,
                    depthWrite: false,
                });
                const backgroundMesh = new THREE.Mesh(backgroundGeometry, this.backgroundMaterial);
                backgroundMesh.renderOrder = -1;
                this.scene.add(backgroundMesh);
            }
            
            createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 64, 64);
                return new THREE.CanvasTexture(canvas);
            }

            createOrUpdateParticles() {
                if (this.particlesGroup) {
                    this.scene.remove(this.particlesGroup);
                    this.particleGeometry.dispose();
                }

                this.particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.params.particleCount * 3);
                const depths = new Float32Array(this.params.particleCount);
                const colors = new Float32Array(this.params.particleCount * 3);
                const twinkleOffsets = new Float32Array(this.params.particleCount);

                const primaryColor = new THREE.Color(this.params.particleColor1);
                const secondaryColor = new THREE.Color(this.params.particleColor2);
                const highlightColor = new THREE.Color(this.params.particleHighlightColor);

                for (let i = 0; i < this.params.particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 2 * PARTICLE_RANGE;
                    positions[i3 + 1] = (Math.random() - 0.5) * 2 * PARTICLE_RANGE;
                    positions[i3 + 2] = (Math.random() - 0.5) * 2 * PARTICLE_RANGE;
                    depths[i] = (positions[i3 + 2] + PARTICLE_RANGE) / (2 * PARTICLE_RANGE);
                    twinkleOffsets[i] = Math.random() * Math.PI * 2;
                    
                    let baseColor = Math.random() < 0.05 ? highlightColor : (Math.random() < 0.4 ? secondaryColor : primaryColor);
                    const particleColor = new THREE.Color(baseColor);
                    const hsl = { h: 0, s: 0, l: 0 };
                    particleColor.getHSL(hsl);
                    particleColor.setHSL(
                        hsl.h + (Math.random() - 0.5) * 0.05,
                        Math.max(0, Math.min(1, hsl.s * (0.7 + Math.random() * 0.5))),
                        Math.max(0, Math.min(1, hsl.l * (0.6 + Math.random() * 0.7)))
                    );
                    colors[i3] = particleColor.r; colors[i3+1] = particleColor.g; colors[i3+2] = particleColor.b;
                }

                this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.particleGeometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));
                this.particleGeometry.setAttribute('colorAttrib', new THREE.BufferAttribute(colors, 3));
                this.particleGeometry.setAttribute('twinkleOffsetAttrib', new THREE.BufferAttribute(twinkleOffsets, 1));

                if (!this.particleMaterial) {
                    this.particleMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                          pointTexture: { value: this.particleTexture },
                          opacityFalloff: { value: this.params.opacityFalloff },
                          uParticleSizeBase: { value: this.params.particleSize },
                          u_time: { value: 0.0 },
                          uAudioInfluence: { value: 0.0 },
                        },
                        vertexShader: PARTICLE_VERTEX_SHADER,
                        fragmentShader: PARTICLE_FRAGMENT_SHADER,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false, transparent: true,
                    });
                } else {
                    this.updateParticleUniforms();
                }

                this.particlesGroup = new THREE.Points(this.particleGeometry, this.particleMaterial);
                this.scene.add(this.particlesGroup);
            }
            
            updateAllUniforms() {
                this.updateBackgroundUniforms();
                this.updateParticleUniforms();
            }

            updateBackgroundUniforms() {
                if (!this.backgroundMaterial) return;
                const uniforms = this.backgroundMaterial.uniforms;
                uniforms.u_nebulaBaseCol1.value.set(this.params.nebulaColor1);
                uniforms.u_nebulaBaseCol2.value.set(this.params.nebulaColor2);
                uniforms.u_nebulaAccentCol1.value.set(this.params.nebulaAccent1);
                uniforms.u_nebulaAccentCol2.value.set(this.params.nebulaAccent2);
                uniforms.u_nebulaOctaves.value = this.params.nebulaOctaves;
                uniforms.u_nebulaScale.value = this.params.nebulaScale;
                uniforms.u_nebulaSpeed.value = this.params.nebulaSpeed;
                uniforms.u_nebulaBrightness.value = this.params.nebulaBrightness;
                uniforms.u_nebulaColorMixFactor1.value = this.params.nebulaColorMixFactor1;
                uniforms.u_nebulaDynamicShiftIntensity.value = this.params.nebulaDynamicShiftIntensity;
            }

            updateParticleUniforms() {
                if (!this.particleMaterial) return;
                const uniforms = this.particleMaterial.uniforms;
                uniforms.opacityFalloff.value = this.params.opacityFalloff;
                uniforms.uParticleSizeBase.value = this.params.particleSize;
                this.renderer.setPixelRatio(this.params.resolution);
            }
            
            async toggleAudioReactivity(enabled) {
                if (enabled) {
                    try {
                        const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                        this.mediaStream = stream;
                        const audioTracks = stream.getAudioTracks();
                        if (audioTracks.length > 0) {
                            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const source = this.audioContext.createMediaStreamSource(stream);
                            this.analyser = this.audioContext.createAnalyser();
                            this.analyser.fftSize = 256;
                            source.connect(this.analyser);
                            this.audioDataArray = new Uint8Array(this.analyser.frequencyBinCount);
                            audioTracks[0].onended = () => this.toggleAudioReactivity(false);
                        } else {
                           stream.getTracks().forEach(track => track.stop());
                           this.params.audioReactivityEnabled = false;
                           this.updateUIControl('audioReactivityEnabled', false);
                        }
                    } catch(err) {
                        this.params.audioReactivityEnabled = false;
                        this.updateUIControl('audioReactivityEnabled', false);
                    }
                } else {
                    if (this.mediaStream) this.mediaStream.getTracks().forEach(track => track.stop());
                    if (this.audioContext) this.audioContext.close();
                    this.analyser = null;
                    this.audioDataArray = null;
                }
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.backgroundMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
                });
                
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = (e.clientX - window.innerWidth / 2) / 4;
                    this.mouseY = (e.clientY - window.innerHeight / 2) / 4;
                });
                
                const panel = document.getElementById('controls-panel');
                const showBtn = document.getElementById('show-controls-btn');
                
                document.getElementById('toggle-visibility-btn').addEventListener('click', () => {
                   panel.classList.add('hidden');
                   showBtn.classList.remove('hidden');
                });
                
                showBtn.addEventListener('click', () => {
                    panel.classList.remove('hidden');
                    showBtn.classList.add('hidden');
                });
                
                let showSettingsIcon = true;
                window.addEventListener('keydown', (e) => {
                    if(document.activeElement.tagName === "INPUT") return; // Ignore if typing in an input
                    const key = e.key.toLowerCase();
                    if (key === 'h') {
                        const isHidden = panel.classList.toggle('hidden');
                        showBtn.classList.toggle('hidden', !isHidden);
                    } else if (key === 'l') {
                        showSettingsIcon = !showSettingsIcon;
                        showBtn.style.display = showSettingsIcon ? 'block' : 'none';
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const elapsedTime = this.clock.getElapsedTime();
                this.backgroundMaterial.uniforms.u_time.value = elapsedTime;
                this.particleMaterial.uniforms.u_time.value = elapsedTime;

                if (this.params.audioReactivityEnabled && this.analyser) {
                    this.analyser.getByteFrequencyData(this.audioDataArray);
                    const average = this.audioDataArray.reduce((a, b) => a + b, 0) / this.audioDataArray.length;
                    const normalized = (average / 255) * this.params.audioSensitivity;
                    this.particleMaterial.uniforms.uAudioInfluence.value = normalized;
                } else {
                    this.particleMaterial.uniforms.uAudioInfluence.value = 0.0;
                }

                if (this.params.mouseInteraction) {
                    this.camera.position.x += (this.mouseX - this.camera.position.x) * 0.02;
                    this.camera.position.y += (-this.mouseY - this.camera.position.y) * 0.02;
                }
                this.camera.lookAt(this.scene.position);

                const positions = this.particleGeometry.attributes.position.array;
                for (let i = 0; i < this.params.particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] += this.params.directionX * this.params.speed;
                    positions[i3 + 1] += this.params.directionY * this.params.speed;

                    if (positions[i3] > PARTICLE_RANGE) positions[i3] = -PARTICLE_RANGE;
                    if (positions[i3] < -PARTICLE_RANGE) positions[i3] = PARTICLE_RANGE;
                    if (positions[i3 + 1] > PARTICLE_RANGE) positions[i3 + 1] = PARTICLE_RANGE;
                    if (positions[i3 + 1] < -PARTICLE_RANGE) positions[i3 + 1] = -PARTICLE_RANGE;
                }
                this.particleGeometry.attributes.position.needsUpdate = true;
                this.renderer.render(this.scene, this.camera);
            }

            // --- UI Control Logic ---
            setupControls() {
              const controlGroups = [
                { title: 'Appearance', controls: ['resolution', 'opacityFalloff', 'particleSize'] },
                { title: 'Movement', controls: ['speed', 'directionY', 'directionX', 'mouseInteraction'] },
                { title: 'Nebula Shape & Motion', controls: ['nebulaOctaves', 'nebulaScale', 'nebulaSpeed', 'nebulaBrightness', 'nebulaColorMixFactor1', 'nebulaDynamicShiftIntensity'] },
                { title: 'Particle Colors', controls: ['particleColor1', 'particleColor2', 'particleHighlightColor'] },
                { title: 'Nebula Background Colors', controls: ['nebulaColor1', 'nebulaColor2', 'nebulaAccent1', 'nebulaAccent2'] },
                { title: 'Audio Reactivity', controls: ['audioReactivityEnabled', 'audioSensitivity'] },
                { title: 'General Configuration', controls: ['particleCount', 'recreate'] }
              ];

              const controlDefinitions = {
                  resolution: { type: 'range', label: 'Resolution', min: 0.1, max: 3, step: 0.1 },
                  opacityFalloff: { type: 'range', label: 'Opacity Falloff', min: 0.1, max: 5, step: 0.1 },
                  particleSize: { type: 'range', label: 'Particle Size', min: 0.1, max: 400, step: 0.1 },
                  speed: { type: 'range', label: 'Speed', min: 0, max: 10, step: 0.005 },
                  directionY: { type: 'range', label: 'Vertical Dir.', min: -1, max: 1, step: 0.05 },
                  directionX: { type: 'range', label: 'Horizontal Dir.', min: -1, max: 1, step: 0.05 },
                  nebulaOctaves: { type: 'range', label: 'Nebula Octaves', min: 1, max: 10, step: 1 },
                  nebulaScale: { type: 'range', label: 'Nebula Scale', min: 0.1, max: 5, step: 0.1 },
                  nebulaSpeed: { type: 'range', label: 'Nebula Speed', min: 0.001, max: 0.05, step: 0.001 },
                  nebulaBrightness: { type: 'range', label: 'Nebula Brightness', min: 0.1, max: 2.5, step: 0.05 },
                  nebulaColorMixFactor1: { type: 'range', label: 'Nebula Base Color Mix', min: 0.1, max: 10, step: 0.1 },
                  nebulaDynamicShiftIntensity: { type: 'range', label: 'Nebula Color Shift', min: 0, max: 0.1, step: 0.005 },
                  particleCount: { type: 'range', label: 'Particle Count', min: 1000, max: 200000, step: 1000, requiresRecreate: true },
                  audioSensitivity: { type: 'range', label: 'Audio Sensitivity', min: 0.01, max: 10, step: 0.01 },
                  particleColor1: { type: 'color', label: 'Primary Color' },
                  particleColor2: { type: 'color', label: 'Secondary Color' },
                  particleHighlightColor: { type: 'color', label: 'Highlight Color' },
                  nebulaColor1: { type: 'color', label: 'Base Color 1' },
                  nebulaColor2: { type: 'color', label: 'Base Color 2' },
                  nebulaAccent1: { type: 'color', label: 'Accent Color 1' },
                  nebulaAccent2: { type: 'color', label: 'Accent Color 2' },
                  mouseInteraction: { type: 'toggle', label: 'Mouse Interaction' },
                  audioReactivityEnabled: { type: 'toggle', label: 'Enable Audio Reactivity', id: 'audio-toggle' },
                  recreate: { type: 'button', label: 'Recreate Universe', id: 'recreate-btn' }
              };
              
              const container = document.getElementById('controls-content');
              container.innerHTML = '';
              
              controlGroups.forEach(group => {
                  if (group.title === 'Audio Reactivity' && !this.params.audioReactivityEnabled && group.controls.length > 1) {
                    group.controls = ['audioReactivityEnabled']; // Only show the toggle
                  }

                  const groupDiv = document.createElement('div');
                  groupDiv.className = 'control-group';
                  groupDiv.innerHTML = `<h3>${group.title}</h3>`;

                  group.controls.forEach(key => {
                      const definition = controlDefinitions[key];
                      const el = this.createControlElement(key, definition);
                      groupDiv.appendChild(el);
                  });
                  container.appendChild(groupDiv);
              });
            }
            
            createControlElement(key, def) {
                const value = this.params[key];
                switch(def.type) {
                    case 'range': {
                        const container = document.createElement('div');
                        container.className = 'input-container';
                        const id = `control-${key}`;
                        const decimals = (def.step < 1) ? (key === 'nebulaSpeed' || key === 'audioSensitivity' ? 3 : 2) : 0;
                        container.innerHTML = `
                            <label for="${id}">${def.label}: <span data-value-for="${key}">${Number(value).toFixed(decimals)}</span></label>
                            <input type="range" id="${id}" min="${def.min}" max="${def.max}" step="${def.step}" value="${value}">
                        `;
                        container.querySelector('input').addEventListener('input', (e) => {
                            this.params[key] = parseFloat(e.target.value);
                            document.querySelector(`[data-value-for="${key}"]`).textContent = this.params[key].toFixed(decimals);
                            if(def.requiresRecreate) return;
                            this.updateAllUniforms();
                        });
                         container.querySelector('input').addEventListener('change', (e) => {
                            if (def.requiresRecreate) {
                                this.createOrUpdateParticles();
                            }
                        });
                        return container;
                    }
                    case 'color': {
                        const container = document.createElement('div');
                        container.className = 'color-input-container';
                        const id = `control-${key}`;
                        container.innerHTML = `<label for="${id}">${def.label}</label>`;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'color-input-wrapper';
                        
                        const colorInput = document.createElement('input');
                        colorInput.type = 'color';
                        colorInput.id = id;
                        colorInput.value = value;

                        const textInput = document.createElement('input');
                        textInput.type = 'text';
                        textInput.value = value;
                        
                        colorInput.addEventListener('input', e => {
                            textInput.value = e.target.value;
                            this.params[key] = e.target.value;
                            if (key.includes('particle')) { this.createOrUpdateParticles(); }
                            else { this.updateAllUniforms(); }
                        });
                        
                        textInput.addEventListener('change', e => {
                           colorInput.value = e.target.value;
                           this.params[key] = e.target.value;
                           if (key.includes('particle')) { this.createOrUpdateParticles(); }
                           else { this.updateAllUniforms(); }
                        });
                        
                        wrapper.append(colorInput, textInput);
                        container.append(wrapper);
                        return container;
                    }
                    case 'toggle': {
                        const container = document.createElement('div');
                        container.className = 'toggle-container';
                        const button = document.createElement('button');
                        button.id = def.id || `control-${key}`;
                        button.textContent = value ? 'Enabled' : 'Disabled';
                        button.className = value ? 'enabled' : 'disabled';
                        
                        container.innerHTML = `<label for="${button.id}">${def.label}</label>`;
                        container.appendChild(button);

                        button.addEventListener('click', () => {
                            this.params[key] = !this.params[key];
                            this.updateUIControl(key, this.params[key]);
                            if (key === 'audioReactivityEnabled') {
                                this.toggleAudioReactivity(this.params[key]);
                                this.setupControls(); // Redraw controls to show/hide sensitivity
                            }
                        });
                        return container;
                    }
                    case 'button': {
                        const button = document.createElement('button');
                        button.id = def.id;
                        button.textContent = def.label;
                        button.addEventListener('click', () => this.createOrUpdateParticles());
                        return button;
                    }
                }
            }

            updateUIControl(key, value) {
              const button = document.getElementById(`control-${key}`) || document.getElementById('audio-toggle');
              if (button) {
                button.textContent = value ? 'Enabled' : 'Disabled';
                button.className = value ? 'enabled' : 'disabled';
                if(key === 'audioReactivityEnabled' && value) { button.classList.add('enabled'); }
              }
            }
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', () => {
            new VisuStarApp();
        });

    </script>
</body>
</html>
